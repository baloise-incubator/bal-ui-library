import { Project, VariableDeclarationKind } from 'ts-morph'
import { CreateStencilReactComponentOptions, ReactEvent } from './types'
import { dashToPascalCase, eventListenerName } from './utils'

/**
 * Generates React components for Stencil web components.
 *
 * This function creates React components that wrap Stencil web components,
 * allowing them to be used in React applications. It uses an in-memory file
 * system to speed up the process and avoid writing to disk.
 *
 * @param {CreateStencilReactComponentOptions} options - The options for creating the React components.
 * @param {Array<Component>} options.components - The list of Stencil components to wrap.
 * @param {string} options.stencilPackageName - The name of the Stencil package.
 * @param {string} options.customElementsDir - The directory containing the custom elements.
 * @param {string} [options.hydrateModule] - The module used for server-side rendering.
 *
 * @returns {string} The generated TypeScript source code for the React components.
 */
export const createStencilReactComponents = ({
  components,
  stencilPackageName,
  customElementsDir,
  hydrateModule,
}: CreateStencilReactComponentOptions): string => {
  /**
   * Use in memory file system to speed up the process
   * This will not write to disk and use the RAM instead
   */
  const disableEslint = `/* eslint-disable */\n`
  const project = new Project({ useInMemoryFileSystem: true })
  const useClientDirective = !hydrateModule ? `'use client';\n\n` : ''
  const importDirections = hydrateModule
    ? `
* Do __not__ import components from this file as server side rendered components
* may not hydrate due to missing Stencil runtime. Instead, import these components through the generated 'components.ts'
* file that re-exports all components with the 'use client' directive.`
    : ''

  const autogeneratedComment = `/**
* This file was automatically generated by the Baloise Designs system.
* Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.${importDirections}
*/\n\n`

  const runtimeImports = hydrateModule ? 'createComponent, createSSRComponent' : 'createComponent'
  const sourceFile = project.createSourceFile(
    'component.ts',
    `${useClientDirective}${autogeneratedComment}${disableEslint}
import React from 'react';
import { ${runtimeImports} } from './react-component-lib';
import type { EventName, StencilReactComponent } from './react-component-lib';
  `,
  )

  components.forEach(component => {
    const tagName = component.tagName
    const reactTagName = dashToPascalCase(tagName)
    const componentElement = `${reactTagName}Element`
    const componentCustomEvent = `${reactTagName}CustomEvent`

    sourceFile.addImportDeclaration({
      moduleSpecifier: `${stencilPackageName}/${customElementsDir}/${tagName}.js`,
      namedImports: [
        {
          name: reactTagName,
          alias: componentElement,
        },
        {
          name: 'defineCustomElement',
          alias: `define${reactTagName}`,
        },
      ],
    })

    const publicEvents = (component.events || []).filter(event => !event.internal)
    const events: ReactEvent[] = []

    publicEvents.forEach(publicEvent => {
      const references = publicEvent.complexType.references
      const referenceKeys = Object.keys(references)

      if (referenceKeys.length > 0) {
        /**
         * Import the referenced types from the component library.
         * Stencil will automatically re-export type definitions from the components,
         * if they are used in the component's property or event types.
         */
        (referenceKeys || []).forEach(referenceKey => {
          const reference = references[referenceKey]
          const isGlobalType = reference.location === 'global'
          /**
           * Global type references should not have an explicit import.
           * The type should be available globally.
           */
          if (isGlobalType) {
            return
          }

          sourceFile.addImportDeclaration({
            moduleSpecifier: stencilPackageName,
            namedImports: [
              {
                name: referenceKey,
                isTypeOnly: true,
              },
            ],
          })
        })

        /**
         * Import the CustomEvent type for the web component from the Stencil package.
         *
         * For example:
         * ```
         * import type { ComponentCustomEvent } from 'my-component-library';
         * ```
         */
        sourceFile.addImportDeclaration({
          moduleSpecifier: stencilPackageName,
          namedImports: [
            {
              name: componentCustomEvent,
              isTypeOnly: true,
            },
          ],
        })

        events.push({
          originalName: publicEvent.name,
          name: eventListenerName(publicEvent.name),
          type: `EventName<${componentCustomEvent}<${publicEvent.complexType.original}>>`,
        })
      } else {
        events.push({
          originalName: publicEvent.name,
          name: eventListenerName(publicEvent.name),
          type: 'EventName',
        })
      }
    })

    const componentEventNamesType = `${reactTagName}Events`

    /**
     * Create a type alias for the event names of the component.
     * This type will be used to define the event listeners on the React component.
     */
    sourceFile.addTypeAlias({
      name: componentEventNamesType,
      type:
        events.length > 0
          ? `{ ${events.map(event => `${event.name}: ${event.type}`).join(',\n')} }`
          : 'NonNullable<unknown>',
    })

    /**
     * Create the React component for the custom element.
     * This component will wrap the custom element and provide event listeners for the component's events.
     * This is only used on the client side.
     */
    const clientComponentCall = `
      /*@__PURE__*/ createComponent<${componentElement}, ${componentEventNamesType}>({
        tagName: '${tagName}',
        elementClass: ${componentElement},
        react: React,
        events: {
          ${events.map(event => `${event.name}: '${event.originalName}'`).join(',\n')}
        } as ${componentEventNamesType},
        defineCustomElement: define${reactTagName},
      })
    `

    /**
     * Create the server-side rendering (SSR) component for the custom element.
     * This component will be used to render the custom element on the server side.
     * It will lazy load the `createComponentForServerSideRendering` function and the `hydrateModule`
     * to avoid bundling them in the runtime and serving them in the browser.
     */
    const serverComponentCall = `
      /*@__PURE__*/ createSSRComponent<${componentElement}, ${componentEventNamesType}>({
        tagName: '${tagName}',
        hydrateModule: import('${hydrateModule}'),
      })
    `

    /**
     * Create a constant for the React component.
     * This constant will be used to import the component in the application.
     */
    const reactComponentVariableStatement = sourceFile.addVariableStatement({
      declarationKind: VariableDeclarationKind.Const,
      declarations: [
        {
          name: reactTagName,
          type: `StencilReactComponent<${componentElement}, ${componentEventNamesType}>`,
          initializer: hydrateModule
            ? `typeof window !== 'undefined'
              ? ${clientComponentCall}
              : ${serverComponentCall}`
            : clientComponentCall,
        },
      ],
    })

    // Mark the React component as exported.
    reactComponentVariableStatement.setIsExported(true)
  })

  sourceFile.organizeImports()
  sourceFile.formatText()

  return sourceFile.getFullText()
}
